#!/usr/bin/perl
#
# $Id: wintectool 1627 2010-08-05 22:20:33Z flip $
#
# Tool for Wintec WSG-1000 a.k.a. the slightly fancier Navilock NL-120GR
#
# Copyright (c) 2009, 2015 Philippe Kehl <phkehl @ gmail dot com>
#
# This is free software.
#
# See the contained documentation (POD) for licensing details.
#

package main;

use strict;
use warnings;

use DateTime;
use Getopt::Long qw(:config bundling_override);
use Pod::Usage;
use File::Slurp;
use Carp;

use Data::Dumper;
$Data::Dumper::Terse = 1;


use constant COPYMSG => "wintectool -- Wintec WGS-1000 / Navilock NL-120GR management tool\n"
                      . "Copyright (c) 2009, 2015 Philippe Kehl <phkehl at gmail dot com> et al.";

=pod

=head1 NAME

wintectool -- script to manage a Wintec WGS-1000 / Navilock NL-120GR GPS logger

=head1 DESCRIPTION

Description...

=cut

##
## command line options and default configuration
##
my %gpsopts =
(
    # serial port
    device    => '/dev/gps0',
    baudrate  => 57600,
    parity    => 'none',
    databits  => 8,
    handshake => 'none',

    # wait delay [us] for serial input and retries for serial input before timeout
    # don't make the product of these smaller than 2 seconds
    readdelay => 200,
    timeout   => 10,

    # maximum number of errors (retries) before panicking
    # (when downloading logged data)
    maxerrors => 10,

    # download protocol chunk size
    chunksize => 4096,

    # record length in binary data
    reclen => 16,

    # chunk size for downloading data
    chunksize => 4096,

    # GPS timezone
    gpstimezone => 'UTC',

    # devinfo (name, info, sn) max length
    devinfomaxlen => 19,
);

my %opts =
(
    # verbosity (0 = quiet, 1 = normal, >=2 debugging)
    verbosity => 2, # FIXME: set to 1 in release

    # input file
    from        => '',       # '' = download from device, else read from file

    # output files
    outfiles    => [],       # list of output files

    # default output file spec
    outsplit    => 1,        # {0|1}, create one output file per track
    outdata     => 'tracks', # {tracks|waypoints}, what to output
    outfilespecdefaults =>
    {
        _default => ":split:tracks:wgs84llh",
        bin      => ":nosplit:tracks",
        _split   => "TYPE_YYYYMMDD-HHMI.FMT",
        _nosplit => "TYPE_YYYYMMDD_all.FMT",
    },

    # colourise output?
    colours     => (-t STDOUT ? 1 : 0), # default yes if interactive terminal

    # timezone for output files where appropriate
    timezone => 'Europe/Zurich',

    # other stuff to do
    _doinfo        => 0,
    _dosetname     => '',
    _dosetinfo     => '',
    _dosetsn       => '',
    _dologmode     => undef,
    _dodeletelog   => undef,
    _dodeletemarks => undef,
    _dogetmarks    => undef,
    _dosetmarks    => '',
    _doscreenshot  => undef,
);

=pod

=head1 SYNOPSIS

wintectool [-h|--help|--man]

wintectool [options]

=head1 OPTIONS AND ARGUMENTS

=over

=item C<< B<< -h|--help|--man >> >>

Prints usage info, with options and arguments explained or the full manual, including technical
documentation.

=item C<< B<< --{bin|dat|gpx|kml}[=[filename][:[no]split][:{tracks|waypoints}]][:datum] >> >>

Output file specification. The filename can contain the following placeholders:

=over

=item * I<TYPE> for either "tracks" or "waypoints".

=item * I<YYYY>, I<YY>, I<MM>, I<DD>, I<HH>, I<MI>, I<SS> for year, two-digits year, day, month, hour,
        minute and second of the track start (or first waypoint).

=item * I<N >(or more 'N's for zero padded numbers) for the track number.

=item * I<FMT> for the format.

=back

This flag can be specified multiple times in order to produce multiple output files.

The default output file spec is C<TYPE_YYYYMMDD-HHMI.FMT:split:tracks>.
The I<bin> format uses C<TYPE_YYYYMMDD_all.FMT:nosplit:tracks> per default.

The flags C<--split> (or C<--no-split>), C<--tracks> and C<--waypoints> can be used to override the
defaults for all following output file selectors.

The tracks and waypoint data is downloaded from the device unless C<--from=filename> is specified,
which reads the data from the file I<filename> instead.

Available (gedetic) I<:datum> option are I<:wgs84llh> and I<:swissxyz>. The former is the default
for all output formats. The latter can only be used with the C<--dat> format. It implies
C<--timezone=Europe/Zurich>. Note: do not set the datum option on the I<G0> screen of the logger to
anything other than 'WGS84'.

The C<--timezone> options can be used with C<--dat>. See the documentation for L<DateTime::TimeZone>
for valid arguments (e.g. C<America/Chicago> or C<+0630>).

=item C<< B<< --deletelog >> >>

Deletes all logging data. Really.

Note: apparently the logger can only delete the whole memory (log and marks). Therefore, this
command downloads the marks first, then deletes the memory and finally stores the marks back to the
device.

=item C<< B<< --info >> >> and C<< B<< --no-info >> >>

Do (not) print some info about the device. Needs a connected GPS device.

=item C<< B<< --setname >> >>, C<< B<< --setinfo >> >>, C<< B<< --setsn >> >>

Sets the I<name>, I<info> and serial number string on the device. The 15 first characters of the
I<name> string are visible on the device. The maximum length for all three strings is 19 characters
each.

=item C<< B<< --logmode >> >>, C<< B<< --logmode=format >> >>

Gets and sets the current logging mode parameters. Valid formats are: I<off>, I<course,v0,v1,c>,
I<velocity,v0,x1,x2,x3,v1,i1,i2,i3,i4>, I<time,v0,v1,t>, I<distance,v0,v1,d> and
I<mixed,v0,v1,t,d>. See the section "Logging setup commands" of the manual for details. You need to
set the log mode (screen I<B0> on the device) on the device to "User Mode" for this to work.

=item C<< B<< --getmarks >> >>, C<< B<< --getmarks=filename >> >>, C<< B<< --setmarks=filename >> >>, C<< B<< --deletemarks >>

Download marks from device and, optionally, save them to a file. Reads marks and *adds* them to the
list of marks on the device. Deletes all marks on the device. The commands are executed in this
order: I<getmarks>, I<deletemarks>, I<setmarks>. The mark/file format is:
C<icon#,lat,lon,elevation,name>.

=item C<< B<< --screenshot >> >>

Gets and saves a screenshot from the currently displayed screen to a PNG format file. Optionally
filename without extension can be specified. C<screenshot.png> is the default file name.

=item C<< B<< -v|--verbose >> >>, C<< B<< -q|--quiet >> >>, C<< B<< -c|--colours >> >>

Sets or increases verbosity (0 = quiet, 1 = normal, >= 2 = debugging). Sets verbosity level
0. Forces colourised debug output on/off (1/0).

=item C<< B<< -d|--device >> >>, C<< B<< --baudrate >> >>, C<< B<< --parity >> >>, C<< B<< --databits >> >>

=item C<< B<< --handshake >> >>, C<< B<< --timeout >> >>, C<< B<< --readdelay >> >>

Set serial device to use (e.g. C</dev/ttyUSB0>) as well as its parameters. The default parameters
are: /dev/gps0, 57600, none, 8, none. The last two flags set the number of retries to read data and
delay [ms] between retries (don't make the product of these smaller than 2 seconds).

=back

=head1 EXAMPLES

Get device info:

    wintectool --info

Set owner name:

    wintectool --setname=Schorsch

Retrieve waypoints, edit them, and store them again:

    wintectool --getmarks=meier.txt
    $EDITOR meier.txt
    wintectool --setmarks=meier.txt

=cut

GetOptions(
    # handle cries for help
    'h'    => sub { pod2usage({ -verbose => 0, -exitval => 0, -message => COPYMSG }); },
    'help' => sub { pod2usage({ -verbose => 1, -exitval => 0, -message => COPYMSG }); },
    'man'  => sub { pod2usage({ -verbose => 2, -exitval => 0, -message => COPYMSG }); },

    # debugging
    'v|verbose:+'      => \$opts{verbosity},
    'q|quiet'          => sub { $opts{verbosity} = 0; },
    'c|colours=i'      => \$opts{colours},

    # serial port options
    'd|device=s'       => \$gpsopts{device},
    'baudrate=i'       => \$gpsopts{baudrate},
    'parity=s'         => \$gpsopts{parity},
    'databits=i'       => \$gpsopts{databits},
    'handshake=s'      => \$gpsopts{handshake},

    # gps i/o and data format options
    'readdelay=i'      => \$gpsopts{readdelay},
    'timeout=i'        => \$gpsopts{timeout},
    'maxerrors=i'      => \$gpsopts{maxerrors},
    'chunksize=i'      => \$gpsopts{chunksize},
    'reclen=i'         => \$gpsopts{reclen},

    # data input from file instead of downloading from the device
    'from=s'           => \$opts{from},

    # output file specification flags
    'outsplit|split!'  => \$opts{outsplit},
    'tracks'           => sub { $opts{outdata} = 'tracks'; },
    'waypoints'        => sub { $opts{outdata} = 'waypoints'; },
    # we need to list these all here. we cannot use aliases
    # because $_[0]->{name} will contain the option name
    # if an alias has been specified on the command line
    'bin:s'            => sub { addoutputfile(@_); },
    'dat:s'            => sub { addoutputfile(@_); },
    'kml:s'            => sub { addoutputfile(@_); },
    'gpx:s'            => sub { addoutputfile(@_); },
    'timezone=s'       => \$opts{timezone},

    # get/set info commands
    'info!'            => \$opts{_doinfo},
    'setname=s'        => \$opts{_dosetname},
    'setinfo=s'        => \$opts{_dosetinfo},
    'setsn=s'          => \$opts{_dosetsn},

    # logmode
    'logmode:s'        => \$opts{_dologmode},

    # delete log
    'deletelog:s'      => \$opts{_dodeletelog},

    # marks (POIs)
    'getmarks:s'       => \$opts{_dogetmarks},
    'setmarks=s'       => \$opts{_dosetmarks},
    'deletemarks:s'    => \$opts{_dodeletemarks},

    # screenshot
    'screenshot:s'     => \$opts{_doscreenshot},

) || pod2usage({ -verbose => 0, -exitval => 1 });


##
## setup debugging output
##

$SIG{__DIE__} = sub { DIE(@_); };

# in Windoze, check if we have the appropriate colours translater
if ( $^O =~ m/Win32/i )
{
    eval "local \$^W = 0; require Win32::Console::ANSI;";
    if ($@) # fails loading properly on newer Windozen
    {
        undef $Win32::Console::ANSI::VERSION;
    }
}


##
## say hello
##
NOTICE(COPYMSG);


##
## create our GPS interface object
##
my $gps = WintecGPS->new(\%gpsopts);


##
## set device info
##

if ($opts{_dosetname})
{
    PRINT("Setting device name to '%s'.", $opts{_dosetname});
    $gps->setdevinfo({ name => $opts{_dosetname} });
}

if ($opts{_dosetinfo})
{
    PRINT("Setting device info to '%s'.", $opts{_dosetinfo});
    $gps->setdevinfo({ info => $opts{_dosetinfo} });
}
if ($opts{_dosetsn})
{
    PRINT("Setting device S/N to '%s'.", $opts{_dosetsn});
    $gps->setdevinfo({ sn   => $opts{_dosetsn}   }) ;
}


##
## get some info on the device
##

if ($opts{_doinfo})
{
    my $i = $gps->getdevinfo();
    my $v = $gps->getverinfo();
    my $m = $gps->getmeminfo();
    PRINT("Device Info:\n - name: %s\n - info: %s\n - S/N:  %s\n - sw:   %s\n - hw:   %s\n - fmt:  %s\n - mem:  %.1f%%",
          $i->{name}, $i->{info}, $i->{sn}, $v->{swver}, $v->{hwver}, $v->{fmt}, $m->{memfull});
}

##
## get logging mode
##
if (defined $opts{_dologmode})
{
    if ($opts{_dologmode} eq '')
    {
        PRINT("Current logging mode: %s", $gps->getlogmode());
    }
    else
    {
        PRINT("Setting logging mode to: %s", $opts{_dologmode});
        $gps->setlogmode($opts{_dologmode});
    }
}


##
## download, decode and save log
##

# anything to output?
if ($#{$opts{outfiles}} > -1)
{
    # get data from file or download from device
    my $rawdata = '';
    if ($opts{from})
    {
        PRINT("Reading raw data from '%s'.", $opts{from});
        $rawdata = File::Slurp::read_file($opts{from}, { binmode => ':raw' });
    }
    else
    {
        PRINT("Reading raw data from device.");
        $rawdata = $gps->downloadlog();
    }

    if (length($rawdata))
    {
        PRINT("Got %i bytes.", length($rawdata));
    }
    else
    {
        exit(1);
    }

    # decode data
    $gps->decodedata($rawdata);
    # FIXME: catch errors and set $opts{_dodeletelog} = 0

    # process each output file
    foreach my $outfilespec (@{$opts{outfiles}})
    {
        # compose filename with list of track number(s)
        my @filenames = ();
        my @tracks = ();

        # splitted tracks
        if ($outfilespec->{split})
        {
            for (my $track = 0; $track < $gps->{tracksinfo}->{ntracks}; $track++)
            {
                # timestamp of first trackpoint or waypoint in this track
                my $ts = $gps->{$outfilespec->{outdata}}->[$track]->[0]->{ts};
                my $filename = formatfilename($outfilespec, $ts, 5);
                push(@filenames, $filename);
                push(@tracks, [ $track ]);
            }
        }
        # unsplitted tracks
        else
        {
            # timestamp of first trackpoint or waypoint in first track
            my $ts = $gps->{$outfilespec->{outdata}}->[0]->[0]->{ts};
            my $filename = formatfilename($outfilespec, $ts, 5);
            push(@filenames, $filename);
            push(@tracks, [ 0 .. $#{$gps->{$outfilespec->{outdata}}} ]);

        }

        # write output files
        for (my $n = 0; $n <= $#filenames; $n++)
        {
            # call routine to write this format
            if ($outfilespec->{format} eq 'bin')
            {
                $gps->write_bin($filenames[$n],
                                $tracks[$n], $outfilespec->{outdata});
            }
            if ($outfilespec->{format} eq 'dat')
            {
                $gps->write_dat($filenames[$n],
                                $tracks[$n],
                                $outfilespec->{outdata},
                                $outfilespec->{datum},
                                $opts{timezone});
            }
            if ($outfilespec->{format} eq 'gpx')
            {
                $gps->write_gpx($filenames[$n],
                                $tracks[$n],
                                $outfilespec->{outdata});
            }
        }
    }
}


##
## delete logging memory
##
if (defined $opts{_dodeletelog})
{
    if ($opts{_dodeletelog} eq '')
    {
        ERROR("You must use --deletelog=yes to delete the log and marks memory.");
        exit(1);
    }
    else
    {
        WARNING("Deleting log in 4 seconds. Hit C-c NOW to abort!");
        sleep(4);
        $gps->deletelog();
    }
}


##
## marks
##

if (defined $opts{_dogetmarks})
{
    PRINT("Retrieving marks.");
    my $data = $gps->getmarks($opts{_dogetmarks});

    if ($opts{_dogetmarks})
    {
        PRINT("Storing marks to '%s' (%i bytes).", $opts{_dogetmarks}, length($data));
        File::Slurp::write_file($opts{_dogetmarks}, $data);
    }
    else
    {
        print($data);
    }

}

if (defined $opts{_dodeletemarks})
{
    if ($opts{_dodeletemarks} eq '')
    {
        ERROR("You must use --deletemarks=yes to delete the marks.");
        exit(1);
    }
    else
    {
        WARNING("Deleting marks in 4 seconds. Hit C-c NOW to abort!");
        sleep(4);
        $gps->deletemarks();
    }
}

if ($opts{_dosetmarks})
{
    PRINT("Storing marks from '%s' (%i bytes).", $opts{_dosetmarks}, -s $opts{_dosetmarks});
    my $data = File::Slurp::read_file($opts{_dosetmarks});
    $gps->setmarks($data);
}


##
## screen shot
##

if (defined $opts{_doscreenshot})
{
    PRINT("Taking screenshot.");
    my $png = $gps->screenshot();

    if ($png)
    {
        my $fn = $opts{_doscreenshot} || 'screenshot.png';
        PRINT("Saving screenshot to '%s' (%i bytes).", $fn, length($png));
        File::Slurp::write_file($fn, { binmode => ':raw' }, $png);
    }
    else
    {
        exit(1);
    }
}


##
## say goodbye
##

$gps->restartgps(); # FIXME: to get out of command mode?
NOTICE("All done. Goodbye!");
exit(0);


##
## various funky functions
##

sub WARNING
{
    my $fmt = shift;
    printf(_colour('WARNING') . $fmt . _colour('OFF') . "\n", _stringify(@_));
}

sub ERROR
{
    my $fmt = shift;
    printf(_colour('ERROR') . $fmt . _colour('OFF') . "\n", _stringify(@_));
}

sub NOTICE
{
    my $fmt = shift;
    printf(_colour('NOTICE') . $fmt . _colour('OFF') . "\n", _stringify(@_)) if ($opts{verbosity} > 0);
}

sub PRINT
{
    my $fmt = shift;
    printf(_colour('PRINT') . $fmt . _colour('OFF') . "\n", _stringify(@_)) if ($opts{verbosity} > 1);
}

sub DEBUG1
{
    my $fmt = shift;
    printf(_colour('DEBUG1') . $fmt . _colour('OFF') . "\n", _stringify(@_)) if ($opts{verbosity} > 2);
}

sub DEBUG2
{
    my $fmt = shift;
    printf(_colour('DEBUG2') . $fmt . _colour('OFF') . "\n", _stringify(@_)) if ($opts{verbosity} > 3);
}

sub DEBUG3
{
    my $fmt = shift;
    printf(_colour('DEBUG3') . $fmt . _colour('OFF') . "\n", _stringify(@_)) if ($opts{verbosity} > 3);
}

sub DIE
{
    my $why = shift;
    $why =~ s/\n$//;
    print(STDERR _colour('DIE') . Capr::longmess($why) . _colour('OFF') . "\n");
    exit(1);
}

sub _colour
{
    my $which = shift;
    return '' unless ($opts{colours});

    my %c =
    (
        NOTICE  => "\e[1m",
        PRINT   => "\e[m",
        DEBUG1  => "\e[36m",
        DEBUG2  => "\e[36m",
        DEBUG3  => "\e[36m",
        WARNING => "\e[33m",
        ERROR   => "\e[31m",
        DIE     => "\e[1;31m",
        OFF     => "\e[m",
    );

    return $c{$which} || '';
}

sub _stringify
{
    return map { ref($_) ? Data::Dumper::Dumper($_) : $_ } @_;
}

sub formatfilename
{
    my $outfilespec = shift;
    my $timestamp = shift;
    my $tracknum = shift;

    my $filename = $outfilespec->{filename};

    # format parts of the filename
    $filename =~ s/FMT/$outfilespec->{format}/g;
    $filename =~ s/TYPE/$outfilespec->{outdata}/g;

    my $dt = DateTime->from_epoch(epoch => $timestamp, time_zone => $opts{timezone});
    my $year  = sprintf("%04i", $dt->year());
    my $year2 = sprintf("%02i", $dt->year()-2000);
    my $month = sprintf("%02i", $dt->month());
    my $day   = sprintf("%02i", $dt->day());
    my $hour  = sprintf("%02i", $dt->hour());
    my $min   = sprintf("%02i", $dt->minute());
    my $sec   = sprintf("%02i", $dt->sec());
    $filename =~ s/([^Y]+)YY([^Y]+)/$1$year2$2/g;
    $filename =~ s/YYYY/$year/g;
    $filename =~ s/MM/$month/g;
    $filename =~ s/DD/$day/g;
    $filename =~ s/HH/$hour/g;
    $filename =~ s/MI/$min/g;
    $filename =~ s/SS/$sec/g;

    if ($filename =~ m/(N+)/)
    {
        $tracknum = sprintf('%0' . length($1) . 'i', $tracknum);
        $filename =~ s/$1/$tracknum/;
    }

    return $filename;
}

sub addoutputfile
{
    my $format = (shift)->{name};
    my $arg    = shift || '';

    # default output specs
    my $defspecs;
    if ($opts{outfilespecdefaults}->{$format})
    {
        $defspecs = $opts{outfilespecdefaults}->{$format};
    }
    else
    {
        $defspecs = $opts{outfilespecdefaults}->{_default};
    }

    my ($split, $outname, $filename, $outdata, $datum);
    $filename = '';

    # set defaults from defspecs
    $filename = $1 if ($defspecs =~ m/^([^:]+)/); # will be empty
    $split    = 1  if ($defspecs =~ m/:split/);
    $split    = 0  if ($defspecs =~ m/:nosplit/);
    $outdata  = $1 if ($defspecs =~ m/:(waypoints|tracks)/);
    $datum    = $1 if ($defspecs =~ m/:(wgs84llh|swissxyz)/);

    # override defaults by what is specified in arg (if anything)
    $filename = $1 if ($arg =~ m/^([^:]+)/);
    $split    = 1  if ($arg =~ m/:split/);
    $split    = 0  if ($arg =~ m/:nosplit/);
    $outdata  = $1 if ($arg =~ m/:(waypoints|tracks)/);
    $datum    = $1 if ($arg =~ m/:(wgs84llh|swissxyz)/);

    # set default filename if we don't have that yet
    $filename = $opts{outfilespecdefaults}->{_split}
      if ($filename eq '' && $split);
    $filename = $opts{outfilespecdefaults}->{_nosplit}
      if ($filename eq '' && !$split);

    DEBUG3("format=$format split=$split outdata=$outdata "
            . "filename=$filename datum=$datum");

    # add to list of file
    my %outputfile = ( format => $format, filename => $filename,
                       split => $split, outdata => $outdata,
                       datum => $datum);
    push(@{$opts{outfiles}}, { %outputfile });
}


###############################################################################
##
## A class to handle the Wintec GPS specific stuff
##
###############################################################################

package WintecGPS;

use strict;
use warnings;
#use Device::SerialPort; # load at run-time
#use Win32::SerialPort;  # load at run-time
use Time::HiRes qw( usleep );
use DateTime;
use List::Util qw( sum min max );
use File::Slurp;
use GD;

# wrap main debug printing functions
sub DEBUG1  { main::DEBUG1("WintecGPS[1]: " . (shift), @_); }
sub DEBUG2  { main::DEBUG2("WintecGPS[2]: " . (shift), @_); }
sub DEBUG3  { main::DEBUG3("WintecGPS[3]: " . (shift), @_); }
sub WARNING { main::WARNING("WintecGPS[W]: " . (shift), @_); }
sub ERROR   { main::ERROR("WintecGPS[E]: " . (shift), @_); }

# constructor, takes a hash ref of serial port config
sub new
{
    my $class = shift;
    my $self = {};

    $self->{args} = shift;
    $self->{io} = undef;
    $self->{incommandmode} = 0;

    bless($self, $class);

    # try loading serial port module
    if ($^O =~ m/Win32/i)
    {
        eval
        {
            local $^W = 0;
            #require Win32::API;
            #$Win32API::CommPort::RBUF_Size = $buffersize;
            require Win32::SerialPort;
        };
        if ($@)
        {
            ERROR('Could not load Win32::SerialPort!');
            return undef;
        }
    }
    else # assume Linux
    {
        eval
        {
            local $^W = 0;
            require Device::SerialPort;
        };
        if ($@)
        {
            ERROR('Could not load Device::SerialPort!');
            return undef;
        }
    }


    return $self;
}

# open serial port
sub openserial
{
    my $self = shift;

    # return if port already open
    return if (defined $self->{io}); # port already open

    # initialise serial port object
    DEBUG2("Opening serial port.");

    if ($^O =~ m/Win32/i)
    {
        $self->{io} = Win32::SerialPort->new($self->{args}->{device}) ||
          die("Failed opening port $self->{args}->{device}.");
    }
    else
    {
        $self->{io} = Device::SerialPort->new($self->{args}->{device}) ||
          die("Failed opening port $self->{args}->{device}.");
    }
    $self->{io}->baudrate($self->{args}->{baudrate})               ||
      die("Failed setting baudrate: $self->{args}->{baudrate}.");
    $self->{io}->parity($self->{args}->{parity})                   ||
      die("Failed setting parity: $self->{args}->{parity}.");
    $self->{io}->databits($self->{args}->{databits})               ||
      die("Failed setting databits: $self->{args}->{databits}.");
    $self->{io}->handshake($self->{args}->{handshake})             ||
      die("Failed setting handshake: $self->{args}->{handshake}.");
    $self->{io}->write_settings()                                  ||
      die("Failed writing serial port settings.");
}

# go into command mode
sub gocommandmode
{
    my $self = shift;

    # return if already in command mode
    return if $self->{incommandmode};

    DEBUG1("Going into command mode.");

    # ensure that the serial port is opened
    $self->openserial();

    # go into command mode
    my $retries = 4;
    # set here because else we'll have a deep recursion
    $self->{incommandmode} = 1;
    while ($retries--)
    {
        DEBUG1("Trying again..") if $retries < 3;
        my @res = $self->gpscmd(2,3);
        if ($res[0] eq 'OK')
        {
            $self->{incommandmode} = 2; # confirm command mode
            last;
        }
    }
    if ($self->{incommandmode} != 2)
    {
        die "Unable to go into command mode!";
    }
}

# restart GPS (i.e. leave command mode)
sub restartgps
{
    my $self = shift;
    return if !$self->{incommandmode};

    DEBUG1("Restarting GPS.");

    my @res = $self->gpscmd(2,1);
    die "Unable to restart GPS!" if ($res[0] ne 'OK');

    $self->{incommandmode} = 0;
}

# send a command to the gps and wait for reply and return payload
# and everything before that
sub gpscmd
{
    my $self = shift;

    my ( $a, $b, $c );

    # the command
    if ($#_ >= 0) { $a = shift; $a = ",$a"; } else { $a = ''; }
    if ($#_ >= 0) { $b = shift; $b = ",$b"; } else { $b = ''; }
    if ($#_ >= 0) { $c = shift; $c = ",$c"; } else { $c = ''; }

    # additional arguments to the gpsread routine
    my $gpsreadopts = shift || {};

    # ensure that we are in command mode
    $self->gocommandmode();

    # the command to send
    my $cmd = "\@AL$a$b$c";
    DEBUG2("Sending command: $cmd");

    # drain input
    $self->{io}->purge_rx();

    # send command
    $self->{io}->write("$cmd\n");

    # get response expecting the cmd or else what the user said
    my $expect = $cmd;
    $expect = $gpsreadopts->{expect} if (defined $gpsreadopts->{expect});
    my $t = $self->gpsread($expect, $gpsreadopts);

    # parse reply and return payload and everything we might
    # have seen before the expected string
    my $i = index($t, $expect);
    my $payload = '';
    my $garbage = $t;
    if ($i >= $[)
    {
        $payload = substr($t, $i + length($expect) + 1);
        $payload =~ s/\r*\n.*//g; # remove CRLN and possible garbage beyond
        $garbage = substr($t, 0, $i);
    }
    DEBUG2("Got %i bytes of garbage followed by the payload [%s]",
        length($garbage), $payload);

    return ($payload, $garbage);

}

# read data from gps up to expected result or until timeout
sub gpsread
{
    my $self = shift;

    my $expect = shift || undef;
    my $opts = shift || {};

    my $timeout = $opts->{timeout} ? $opts->{timeout} : $self->{args}->{timeout};

    my $t = '';
    while ($timeout--)
    {
        # wait a bit for the data
        DEBUG3("Waiting.. got %i bytes so far, %i tries left",
                  length($t), $timeout);

        if ($opts->{progress})
        {
            local $| = 1;
            printf("\r > $opts->{progress}: %4i bytes (timeout %i)\r", length($t), $timeout);
        }

        usleep($self->{args}->{readdelay} * 1e3);

        # read from serial port and add to buffer
        my $tt = $self->{io}->input();
        $t .= $tt;

        # debugging
        $tt =~ s/\n/<LF>/gm;
        $tt =~ s/\r/<CR>/gm;
        if ($tt =~ m/[^[:print:]]+/) { $tt = "BINARY: <" . length($tt) . " bytes>"; }
        else { $tt = "ASCII: [$tt]";  }
        DEBUG3("Got [$tt].");

        # leave if we found what we were looking for
        # check that the expected data is followed by a CRLF
        my $i = index($t, $expect);
        if (defined $expect && $i >= $[ && rindex($t, "\r\n") > $i)
        {
            DEBUG3("Got expected data: [$expect].");
            $timeout = 0;
        }
    }

    if ($opts->{progress})
    {
        local $| = 1;
        printf("\r" . (" " x (length($opts->{progress}) + 20)) ."\r");
    }


    # return what we have (will be '' if timeout and no data received at all)
    return $t;
}

# get gps device info
sub getdevinfo
{
    my $self = shift;

    DEBUG1("Getting device info.");

    my $name  = ($self->gpscmd(7,1))[0];
    if ($name eq 'error_cmd')
    {
        WARNING("Could not get device name!");
        $name = '';
    }
    my $info  = ($self->gpscmd(7,2))[0];
    if ($info eq 'error_cmd')
    {
        WARNING("Could not get device info!");
        $info = '';
    }
    my $sn    = ($self->gpscmd(7,3))[0];;
    if ($sn eq 'error_cmd')
    {
        WARNING("Could not get device serial number!");
        $sn   = '';
    }

    $self->{devinfo} = { name => $name, info => $info, sn => $sn };

    DEBUG1("name=[%s] info=[%s] sn=[%s]",
                 $self->{devinfo}->{name}, $self->{devinfo}->{info}, $self->{devinfo}->{sn});

    return $self->{devinfo};
}

# set gps device info
sub setdevinfo
{
    my $self = shift;
    my $args = shift;

    # get device info if not available
    $self->getdevinfo() if (!defined $self->{devinfo});

    foreach my $key (sort keys %{$args})
    {
        # only if valid key
        next if ($key ne 'name' && $key ne 'info' && $key ne 'sn');

        # only if not already set
        if ($args->{$key} ne $self->{devinfo}->{$key})
        {
            # remove unprintable chars and commas
            $args->{$key} =~ s/[^[:print:]]*//g;
            $args->{$key} =~ s/,/_/g;

            # truncate too long strings
            if (length($args->{$key}) > $self->{args}->{devinfomaxlen})
            {
                WARNING("Truncating too long string for '$key'.");
                $args->{$key} = substr($args->{$key}, 0, $self->{args}->{devinfomaxlen});
            }

            DEBUG1("Setting devinfo '%s' to [%s] (was: [%s]).",
                   $key, $args->{$key}, $self->{devinfo}->{$key});

            my $b = $key eq 'name' ? 1 : $key eq 'info' ? 2 : 3;
            my @res = $self->gpscmd(7,$b,$args->{$key});
            if ($res[0] eq 'OK')
            {
                # update cached data
                $self->{devinfo}->{$key} = $args->{$key};
            }
            else
            {
                ERROR("Failed setting devinfo '$key'!");
            }
        }
    }
    return $self->{devinfo};
}


# get gps version info
sub getverinfo
{
    my $self = shift;

    DEBUG1("Getting version info.");

    my $hwver = ($self->gpscmd(8,1))[0];
    if ($hwver eq 'error_cmd')
    {
        WARNING("Could not get device hwver!");
        $hwver = '';
    }
    my $swver = ($self->gpscmd(8,2))[0];
    if ($swver eq 'error_cmd')
    {
        WARNING("Could not get device swver!");
        $swver = '';
    }
    my $fmt = ($self->gpscmd(8,3))[0];
    if ($fmt eq 'error_cmd')
    {
        WARNING("Could not get device fmt!");
        $fmt   = '';
    }

    $self->{verinfo} = { hwver => $hwver, swver => $swver, fmt => $fmt };

    DEBUG1("hwver=[%s] swver=[%s] fmt=[%s]",
           $self->{verinfo}->{hwver}, $self->{verinfo}->{swver}, $self->{verinfo}->{fmt});

    return $self->{verinfo};
}

# get gps log memory info
sub getmeminfo
{
    my $self = shift;

    DEBUG1("Getting memory info.");

    my $memid      = ($self->gpscmd(4,1))[0];
    my $memstart   = ($self->gpscmd(5,9))[0];
    my $memend     = ($self->gpscmd(5,10))[0];
    my $memsize    = $memend - $memstart;
    my $logstart   = ($self->gpscmd(5,1))[0];
    my $logend     = ($self->gpscmd(5,2))[0];
    my $logsize    = -1;
    my $loglimit   = -1;
    if ( ($logstart == 0) && ($logend == 0) )
    {
        $logsize = 0;
    }
    elsif ($logstart < $logend) # contigous
    {
        $logsize  = $logend - $logstart;
    }
    else # wrapped around memory end
    {
        $logsize  = $memend - ($logstart - $logend);
    }
    my $logn       = $logsize / $self->{args}->{reclen};
    my $memfull    = $logsize / $memsize * 100;

    # number of marks
    my $nmarks = ($self->gpscmd(10,4))[0];

    $self->{meminfo} =
    {
        memid => $memid, memstart => $memstart,
        memend => $memend, memsize => $memsize,
        memfull => $memfull,
        logstart => $logstart, logend => $logend,
        logsize => $logsize, logn => $logn,
        nmarks => $nmarks,
    };

    DEBUG1("id=0x%04x, region=0x%06x:0x%06x (%.2fMB)",
                $self->{meminfo}->{memid}, $self->{meminfo}->{memstart}, $self->{meminfo}->{memend},
                $self->{meminfo}->{memsize}/1024/1024);
    DEBUG1("%i records \@ 0x%06x:0x%06x, %i bytes (log memory %.1f%% full)",
                $self->{meminfo}->{logn}, $self->{meminfo}->{logstart}, $self->{meminfo}->{logend},
                $self->{meminfo}->{logsize}, $self->{meminfo}->{memfull});
    DEBUG1("%i marks stored on device", $self->{meminfo}->{nmarks});

    return $self->{meminfo};
}


# download log from gps
sub downloadlog
{
    my $self = shift;

    # get memory info if not cached
    $self->getmeminfo() if (!defined $self->{meminfo});

    DEBUG1("Downloading log.");

    # check if there is anything at all
    my $logsize = $self->{meminfo}->{logsize};
    if ($logsize <= 0)
    {
        DEBUG1("Log is empty. Nothing to download.");
        return 0;
    }
    my $nchunks = int( ($logsize / $self->{args}->{chunksize}) + 0.99999 );

    # download data
    my $chunks = 1;
    my $maxerrors = $self->{args}->{maxerrors};
    my $rawdata = '';
    my $logread = $self->{meminfo}->{logstart}; # current read address
    # the read operation takes longer than other operations, increase
    # the number of retries to read the whole chunk
    my $timeout = $self->{args}->{timeout} * 4;
    while ($logsize > 0 && $maxerrors > 0)
    {
        DEBUG1("Reading chunk %03i/%03i @ 0x%06x (%i bytes left)",
               $chunks, $nchunks, $logread, $logsize);

        # poll a chunk of data at address
        my $chunksize = min( ($self->{args}->{chunksize}, $logsize ) );
        my @res = $self->gpscmd(5, 3, $logread,
            { expect => '@AL,CS', timeout => $timeout, progress => "Reading chunk $chunks/$nchunks" });

        # retry if we didn't get anything
        if ($res[1] eq '')
        {
            $maxerrors--;
            WARNING("No data while trying to read chunk %i/%i. %i retries left.",
                    $chunks, $nchunks, $maxerrors);
            next;
        }

        # retry if we didn't get enough data
        my $payloadlen = length($res[1]);
        if ($payloadlen != $chunksize)
        {
            WARNING("Not enough data while trying to read chunk %i/%i (%i < %i). %i retries left.",
                    $chunks, $nchunks, $payloadlen, $chunksize, $maxerrors);
            next;
        }

        # extract, calculate and compare checksum and address
        my $plcs = -1;
        my $addr = -1;
        if ($res[0] =~ m/^([^,]{1,2}),([0-9]{1,10})/)
        {
            $plcs = hex($1);
            $addr = $2;
        }
        my $cs = 0x00;
        foreach (split(//m, $res[1])) { $cs ^= ord($_); }
        if ($cs != $plcs || $addr != $logread)
        {
            $maxerrors--;
            WARNING("Checksum and/or address error in chunk %i/%i (0x%02x != 0x%02x, 0x%06x != 0x%06x). %i retries left.",
                    $chunks, $nchunks, $cs, $plcs, $addr, $logread, $maxerrors);
            next;
        }

        # store data and prepare to get the next chunk
        DEBUG2("$payloadlen bytes OK");
        $rawdata .= $res[1];

        # advance read pointer and decrease number of bytes still to read
        # handle log memory wrapped around memory end
        $logsize -= $payloadlen;
        $logread += $payloadlen;
        if ($logread >= $self->{meminfo}->{memend})
        {
            $logread = $self->{meminfo}->{memstart};
        }
        $chunks++;
    }

    DEBUG1("Got %i bytes.", length($rawdata));

    # return error if failed
    if ($maxerrors <= 0)
    {
        ERROR("Too many errors and/or timeouts!");
        $rawdata = '';
    }

    return $rawdata;
}

# delete log and marks memory
sub deletelog
{
    my $self = shift;

    # delete log memory (and marks memory)
    DEBUG1("Deleting log memory.");
    # can take longer..
    my $timeout = $self->{args}->{timeout} * 4;
    my @res = $self->gpscmd(5,4,'', { timeout => $timeout });

    return $res[0];
}

# decode data
sub decodedata
{
    my $self = shift;
    my $rawdata = shift;


    # FIXME: we should check this (see FIXME in write_bin())
    ## get version info if not cached
    #$self->getverinfo() if (!defined $self->{verinfo});
    #
    ## assert that we can handle this data
    #if ($self->{verinfo}->{fmt} != 2)
    #{
    #    DEBUG1("Can only decode version 2 format.");
    #    return undef;
    #}

    DEBUG1("Decoding raw data.");

    # initialise data structures
    # these are arrays of tracks/waypoints, which are arrays of records or,
    # in case of raw data, strings with the binary data
    $self->{tracks} = [];
    $self->{waypoints} = [];
    $self->{tracksraw} = [];
    $self->{waypointsraw} = [];

    # FIXME: maybe we should delete() previously decoded data here or check
    # that it is not already decoded. (should not be a problem usually)

    # decode
    my $datalen = length($rawdata);
    my $datapos = 0;
    my $ntracks = -1;
    my $nrecords = -1;
    my $dt_gps = DateTime->now(time_zone => $self->{args}->{gpstimezone});
    while ($datapos < $datalen)
    {
        # break up binary record into an array of values
        my $raw = substr($rawdata, $datapos, $self->{args}->{reclen});
        my @v = unpack('S<L<l<l<s<', $raw);

        # decode values
        my $flags  = $v[0] & 0x03;                   # 2 bits
        my $temp   = (($v[0] >> 2) & 0x1f) * 2 - 10; # 5 bits
        my $pres   = (($v[0] >> 7) & 0x1ff) + 589;   # 9 bits

        my $second = ($v[1] >>  0) & 0x3f;           # 6 bits
        my $minute = ($v[1] >>  6) & 0x3f;           # 6 bits
        my $hour   = ($v[1] >> 12) & 0x1f;           # 5 bits
        my $day    = ($v[1] >> 17) & 0x1f;           # 6 bits
        my $month  = ($v[1] >> 22) & 0x0f;           # 4 bits
        my $year   =(($v[1] >> 26) & 0x3f) + 2000;   # 6 bits

        my $lat   = $v[2] / 1e7;                     # 32 bits unsigned

        my $lon   = $v[3] / 1e7;                     # 32 bits unsigned

        my $ele   = $v[4];                           # 16 bits unsigned

        # create posix timestamp from date/time
        $dt_gps->set(second => $second, minute => $minute, hour => $hour,
                     day => $day, month => $month, year => $year);
        my $ts = $dt_gps->epoch();

        # compose record
        my %record = (
                      ts => $ts, flags => $flags,
                      lat => $lat, lon => $lon, ele => $ele,
                      temp => $temp, pres => $pres
                     );
        $nrecords++;

        my $dbgtmp = "$ts ($day.$month.$year $hour:$minute:$second) / "
          . "$lat $lon $ele / $temp $pres / $flags";
        DEBUG3("$dbgtmp");

        # new track (always if first record)
        if ($flags & 0x01 || ($ntracks < 0 && $nrecords == 0))
        {
            $ntracks++;
            $nrecords = 0;
            DEBUG2("New track #%i", $ntracks+1);
        }

        # store waypoints
        if ($flags & 0x02)
        {
            #DEBUG3("WAYPOINT: $dbgtmp");
            push(@{$self->{waypoints}->[$ntracks]}, {%record});
            $self->{waypointsraw}->[$ntracks] .= $raw;
        }

        # store track data
        push(@{$self->{tracks}->[$ntracks]}, {%record});
        $self->{tracksraw}->[$ntracks] .= $raw;

        # next record
        $datapos += $self->{args}->{reclen};
    }

    # count number of records, waypoints and tracks and find bounds/extents
    $ntracks = $#{$self->{tracks}} + 1;
    my @nwaypoints;
    my @nrecords;
    my @bounds; # extent per track
    my @extent = ( +90, -90, +180, -180 ); # of all tracks
    for (my $i = 0; $i < $ntracks; $i++)
    {

        # bounds (extent) for this track
        my @bound = ( +90, -90, +180, -180 );
        for (my $j = 0; $j < $#{$self->{tracks}->[$i]}+1; $j++)
        {
            $bound[0] = min($self->{tracks}->[$i]->[$j]->{lat}, $bound[0]);
            $bound[1] = max($self->{tracks}->[$i]->[$j]->{lat}, $bound[1]);
            $bound[2] = min($self->{tracks}->[$i]->[$j]->{lon}, $bound[2]);
            $bound[3] = max($self->{tracks}->[$i]->[$j]->{lon}, $bound[3]);
        }
        push(@bounds, [@bound]);
        DEBUG2("Bounds of track #%i: %f %f %f %f", $i+1,
                    $bound[0], $bound[1], $bound[2], $bound[3]);

        # update total extent
        $extent[0] = min($bound[0], $extent[0]);
        $extent[1] = max($bound[1], $extent[1]);
        $extent[2] = min($bound[2], $extent[2]);
        $extent[3] = max($bound[3], $extent[3]);

        # keep a list of the number of points in each track
        push(@nwaypoints, $#{$self->{waypoints}->[$i]}+1);
        push(@nrecords, $#{$self->{tracks}->[$i]}+1);
    }
    DEBUG2("Total extent: %f %f %f %f",
           $extent[0], $extent[1], $extent[2], $extent[3]);

    # store metadata
    $self->{tracksinfo} = { ntracks => $ntracks,
                            nwaypoints => [@nwaypoints],
                            nrecords => [@nrecords],
                            bounds => [@bounds],
                            extent => [@extent]};

    DEBUG1("Got %i tracks with %s (=%i) records and %s (=%i) waypoints.",
           $ntracks,
           join("+", @{$self->{tracksinfo}->{nrecords}}),
           sum(@{$self->{tracksinfo}->{nrecords}}),
           join("+", @{$self->{tracksinfo}->{nwaypoints}}),
           sum(@{$self->{tracksinfo}->{nwaypoints}}));

    return $self->{tracksinfo};
}

# get marks from device
sub getmarks
{
    my $self = shift;
    my $outputfile = shift || '';

    if (defined $self->{marks})
    {
        DEBUG1("Marks already downloaded.");
        return;
    }

    my $outputdata = "# icon,lat,lon,ele,name\n";
    my $nmarks = ($self->gpscmd(10,4))[0];

    if ($nmarks == 0)
    {
        DEBUG1("No marks stored on the device.");
    }
    else
    {
        DEBUG1("Retrieving %i marks stored on the device.", $nmarks);
        for (my $n = 0; $n < $nmarks; $n++)
        {
            my @res = $self->gpscmd(10,2,$n);
            #DEBUG1("mark #%02i: %s\n", $n+1, $res[0]);
            if ($res[0] =~ m/^([0-9]+),([0-9]+),([-0-9]+\.[0-9]+),([-0-9]+\.[0-9]+),([0-9]+),([^,]+)$/
               && $1 == $n)
            {
                my $icon = $2;
                my $lat = $3;
                my $lon = $4;
                my $ele = $5;
                my $name = $6;
                my %mark = ( icon => $icon, lat => $lat, lon => $lon,
                             ele => $ele, name => $name, );

                $outputdata .= "$icon,$lat,$lon,$ele,$name\n";
                DEBUG1("icon=%3i lat=%9.5f lon=%10.5f ele=%i name=%s",
                            $icon, $lat, $lon, $ele, $name);

                push(@{$self->{marks}}, { %mark });
            }
            else
            {
                DEBUG1("Cannot parse mark #%02i: %s", $n+1, $res[0]);
            }
            # sleeping a bit here seems to help
            usleep(200e3);
        }
    }

    return $outputdata;
}

# set marks on device
sub setmarks
{
    my $self = shift;
    my $data = shift;

    my @marks;

    $self->gocommandmode();

    # process previously downloaded marks if magic is used
    if ($data eq '*')
    {
        die "No marks!" if (!defined $self->{marks});
        foreach my $mark (@{$self->{marks}})
        {
            push(@marks, sprintf("%i,%.5f,%.5f,%i,%s",
                                 $mark->{icon}, $mark->{lat}, $mark->{lon},
                                 $mark->{ele}, $mark->{name}));
        }
    }
    else
    {
        @marks = split(/\r*\n/, $data);
        # FIXME: catch errors
    }

    if ($#marks == -1)
    {
        WARNING("No marks data available!");
        return;
    }

    my $line = 0;
    foreach my $mark (@marks)
    {
        $line++;
        # skip comments and empty lines
        next if ($mark =~ m/^#|^$/);

        # check format and store mark
        if ( ($mark =~ m/^([0-9]+),([-0-9]+\.[0-9]+),([-0-9]+\.[0-9]+),([0-9]+),([^,]+)$/) &&
            ($1 >= 0) && ($1 < 256) && ($2 >= -90) && ($2 <= 90) &&
            ($3 >= -180) && ($3 <= 180) && ($4 >= 0) && ($4 <= 20000)) # FIXME: min/max height?
        {
            my ($icon, $lat, $lon, $ele, $name) = ($1, $2, $3, $4, $5);
            my $cmd = sprintf("%i,%.5f,%.5f,%i,%s",
                              $1, $2, $3, $4, substr($5, 0, 12));
            DEBUG1("Storing mark: %s", $cmd);
            $self->gpscmd(10,1,$cmd);
            usleep(200e3);
        }
        else
        {
            WARNING("Badly formatted line #%i: %s", $line, $mark);
        }
    }
}

# delete marks from device
sub deletemarks
{
    my $self = shift;
    DEBUG1("Deleting marks stored on the device.");
    return ($self->gpscmd(10,3))[0]
}

# write binary dump of the data
sub write_bin
{
    my $self = shift;
    my $filename = shift || die "Need filename!";
    my $tracks   = shift || die "Need reference to list of tracks!";
    my $outdata  = shift || die "Need to know what data to save!";

    # add or increment suffix to filename if file exists
    $filename = $self->makefilename($filename);

    # FIXME: store TK1 header with data format version etc.
    DEBUG1("Saving binary %s data for tracks %s to %s.",
                $outdata,
                join(", ", map { $_ + 1 } @{$tracks}), $filename);

    # save track(s) to file
    foreach my $track (@{$tracks})
    {
        # skip if we do not have data for this track
        if (!defined $self->{$outdata."raw"}->[$track])
        {
            DEBUG1("No data for track #%i, nothing to save.", $track+1);
            next;
        }

        DEBUG2("Appending binary data for track #%i to %s.",
                    $track+1, $filename);

        # append to file
        File::Slurp::write_file($filename, { binmode => ':raw', append => 1 },
                   $self->{$outdata."raw"}->[$track]);
    }
}


# write ASCII
sub write_dat
{
    my $self = shift;
    my $filename = shift || die "Need filename!";
    my $tracks   = shift || die "Need reference to list of tracks!";
    my $outdata  = shift || die "Need to know what data to save!";
    my $datum    = shift || die "Need to know which datum to use!";
    my $timezone = shift || 'UTC';

    # add or increment suffix to filename if file exists
    $filename = $self->makefilename($filename);

    DEBUG1("Saving ASCII %s data for tracks %s to %s.",
                $outdata,
                join(", ", map { $_ + 1 } @{$tracks}), $filename);

    # switch to Swiss timezone if user selected swissxyz
    $timezone = 'Europe/Zurich' if ($datum eq 'swissxyz');

    # write header
    my $header = '';
    $header = '# x y z'       if ($datum eq 'swissxyz');
    $header = '# lat lon ele' if ($datum eq 'wgs84llh');
    $header .= " unix_timestamp date time temp pres (flags)\n";
    File::Slurp::write_file($filename, { binmode => ':raw', append => 1 }, $header);

    # save track(s) to file
    foreach my $track (@{$tracks})
    {
        # skip if we do not have data for this track
        if (!defined $self->{$outdata."raw"}->[$track])
        {
            DEBUG1("No data for track #%i, nothing to save.", $track+1);
            next;
        }

        DEBUG2("Appending ASCII track data for track #%i to %s.",
                    $track+1, $filename);

        my $trackdata = '';
        my $rec;

        for (my $i = 0; $i < $#{$self->{$outdata}->[$track]}; $i++)
        {
            $rec = $self->{$outdata}->[$track]->[$i];
            my $dt = DateTime->from_epoch(epoch => $rec->{ts},
                                          time_zone => $opts{timezone});
            if ($datum eq 'wgs84llh')
            {
                $trackdata .= sprintf("%11.7f %11.7f %5i",
                                      $rec->{lat}, $rec->{lon}, $rec->{ele});
            }
            elsif ($datum eq 'swissxyz')
            {
                my @llh = ($rec->{lat}, $rec->{lon}, $rec->{ele});
                my @xyz = $self->llh2xyz_swiss(\@llh);
                # we have approx. 0.011m precision (%.7f in lat/lon data)
                $trackdata .= sprintf("%9.2f %9.2f %5i",
                                      $xyz[0], $xyz[1], $xyz[2]);
            }
            $trackdata .= sprintf(" %i %s %s %3i %4i %s\n",
                                  $rec->{ts}, $dt->dmy('.'), $dt->hms(':'),
                                  $rec->{temp}, $rec->{pres},
                                  ($rec->{flags} & 0x02 ? ' WAYPOINT' : ''));
        }
        # add GNUplot style dataset separator
        $trackdata .= "\n\n";

        # append data to file
        File::Slurp::write_file($filename, { append => 1 }, $trackdata);
    }
}

# write KML format
sub write_kml
{
    my $self = shift;
    my $filename = shift || die "Need filename!";
    my $tracks   = shift || die "Need reference to list of tracks!";
    my $outdata  = shift || die "Need to know what data to save!";

    DEBUG1("Saving KML format is *** NOT IMPLEMENTED ***.");
}

# write GPX format
sub write_gpx
{
    my $self = shift;
    my $filename = shift || die "Need filename!";
    my $tracks   = shift || die "Need reference to list of tracks!";
    my $outdata  = shift || die "Need to know what data to save!";

    # add or increment suffix to filename if file exists
    $filename = $self->makefilename($filename);

    DEBUG1("Saving GPX %s data for tracks %s to %s.",
                $outdata,
                join(", ", map { $_ + 1 } @{$tracks}), $filename);

    # write header
    my $header = '<?xml version="1.0" encoding="UTF-8"?>' ." \n"
      . '<gpx version="1.1" creator="wintectool - http://oinkzwurgl.org/wintectool"' ." \n"
      . '     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"' ." \n"
      . '     xmlns="http://www.topografix.com/GPX/1/1"' ." \n"
      . '     xsi:schemaLocation="http://www.topografix.com/GPX/1/1' ." \n"
      . '                         http://www.topografix.com/GPX/1/1/gpx.xsd' ." \n"
      . '                         http://www.topografix.com/GPX/gpx_overlay/0/3' ." \n"
      . '                         http://www.topografix.com/GPX/gpx_overlay/0/3/gpx_overlay.xsd' ." \n"
      . '                         http://www.topografix.com/GPX/gpx_modified/0/1' ." \n"
      . '                         http://www.topografix.com/GPX/gpx_modified/0/1/gpx_modified.xsd">' ." \n";

    # write bounds
    $header .= "  <metadata>\n"
      . sprintf('    <bounds minlat="%.6f" maxlat="%.6f" minlon="%.6f" maxlon="%.6f"/>',
                $self->{tracksinfo}->{extent}->[0], $self->{tracksinfo}->{extent}->[1],
                $self->{tracksinfo}->{extent}->[2], $self->{tracksinfo}->{extent}->[3]) . "\n"
      . '  </metadata>' . "\n";
    File::Slurp::write_file($filename, { append => 1 }, $header);


    # write all tracks
    my $trackNum = 1;
    foreach my $track (@{$tracks})
    {
        # skip if we do not have data for this track
        if (!defined $self->{$outdata."raw"}->[$track])
        {
            DEBUG1("No data for track #%i, nothing to save.", $track+1);
            next;
        }

        DEBUG2("Appending GPX track data for track #%i to %s.",
                    $track+1, $filename);

        # open track
        my $trackdata = '  <trk>' . "\n"
          . '    <name>Track #' . $trackNum . '</name>' . "\n"
          . '    <trkseg>' . "\n";
        # FIXME: TODO: add desc

        # write all track points
        for (my $i = 0; $i < $#{$self->{$outdata}->[$track]}; $i++)
        {
            my $rec = $self->{$outdata}->[$track]->[$i];

            # open the waypoint or track point
            $trackdata .= '      <' . ($rec->{flags} & 0x02 ? 'wpt' : 'trkpt')
              . ' lat="' . $rec->{lat} . '" lon="' . $rec->{lon} . '">';

            # add elevation
            $trackdata .= '<ele>' . $rec->{ele} . '</ele>';

            # write the time in SOAP xsd format
            my $dt = DateTime->from_epoch(epoch => $rec->{ts}, time_zone => 'UTC');
            $trackdata .= '<time>' . $dt->ymd('-') . 'T' . $dt->hms(':') . "Z</time>";

            # FIXME: TODO: write extensions for trkpt

            # close the waypoint or trackpoint
            $trackdata .= '</'. ($rec->{flags} & 0x02 ? 'wpt' : 'trkpt') . ">\n";

        }

        # close the track
        $trackdata .= "    </trkseg>\n";
        $trackdata .= "  </trk>\n";

        $trackNum++;
        # flush data to file
        File::Slurp::write_file($filename, { append => 1 }, $trackdata);
    }

    # close the gpx tag
    File::Slurp::write_file($filename, { append => 1 }, "</gpx>\n");
}


# logging modes (by name and by index)
use constant LOGMODESNAMES => { off => 0, course => 1, velocity => 2,
                                time => 3, distance => 4, mixed => 5, };
use constant LOGMODESINDEX => qw(off course velocity time distance mixed);

# gets log mode information
sub getlogmode
{
    my $self = shift;

    # read all logging mode parameters
    DEBUG1("Getting logging mode.");
    # FIXME: add error checking (test for timeouts)
    my $m  = ($self->gpscmd(6,1))[0];
    my $mode = (LOGMODESINDEX)[$m];
    my $v0 = ($self->gpscmd(6,2))[0];
    my $v1 = ($self->gpscmd(6,3))[0];
    my $c  = ($self->gpscmd(6,4))[0];
    my $x1 = ($self->gpscmd(6,5))[0];
    my $x2 = ($self->gpscmd(6,6))[0];
    my $x3 = ($self->gpscmd(6,7))[0];
    my $i1 = ($self->gpscmd(6,9))[0];
    my $i2 = ($self->gpscmd(6,10))[0];
    my $i3 = ($self->gpscmd(6,11))[0];
    my $i4 = ($self->gpscmd(6,12))[0];
    my $t  = ($self->gpscmd(6,13))[0];
    my $d  = ($self->gpscmd(6,14))[0];

    %{$self->{logmode}} = (
                           m => $m, mode => $mode,
                           v0 => $v0, v1 => $v1,
                           c => $c,
                           x1 => $x1, x2 => $x2, x3 => $x3,
                           i1 => $i1, i2 => $i2, i3 => $i3, i4 => $i4,
                           t => $t, d => $d,
                          );

    DEBUG1("m=%i mode=%s v0=%i v1=%i c=%i x1=%i x2=%i x3=%i "
                . "i1=%i i2=%i i3=%i i4=%i t=%i d=%i",
                $self->{logmode}->{m}, $self->{logmode}->{mode},
                $self->{logmode}->{v0}, $self->{logmode}->{v1}, $self->{logmode}->{c},
                $self->{logmode}->{x1}, $self->{logmode}->{x2}, $self->{logmode}->{x3},
                $self->{logmode}->{i1}, $self->{logmode}->{i2}, $self->{logmode}->{i3},
                $self->{logmode}->{i4}, $self->{logmode}->{t}, $self->{logmode}->{d});

    if    ($m == 0) { return 'off'; }
    elsif ($m == 1) { return "course,$v0,$v1,$c"; }
    elsif ($m == 2) { return "velocity,$v0,$x1,$x2,$x3,$v1,$i1,$i2,$i3,$i4"; }
    elsif ($m == 3) { return "time,$v0,$v1,$t"; }
    elsif ($m == 4) { return "distance,$v0,$v1,$d"; }
    elsif ($m == 5) { return "mixed,$v0,$v1,$t,$d"; }
    else            { return "unknown"; }
}

sub setlogmode
{
    my $self = shift;
    my $logmode = shift || die "Need logmode string.";

    my @cmds;

    # handle log modes
    if ($logmode =~ /^(off)$/)
    {
        my $mode = $1; my $m = (LOGMODESNAMES)->{$mode};
        DEBUG1("Setting logmode '%s': m=%i", $mode, $m);
        push(@cmds, [ 6, 1, $m ]);
    }
    elsif ($logmode =~ /^(course),([0-9]+),([0-9]+),([0-9]+)$/
          && $2 < $3 && $4 > 0 && $4 < 180)
    {
        my $v0 = int($2); my $v1 = int($3);
        my $c = int($4);
        my $mode = $1; my $m = (LOGMODESNAMES)->{$mode};
        DEBUG1("Setting logmode '%s': m=%i v0=%i v1=%i c=%i",
                    $mode, $m, $v0, $v1, $c);
        push(@cmds, [ 6, 2, $v0 ]);
        push(@cmds, [ 6, 3, $v1 ]);
        push(@cmds, [ 6, 4, $c  ]);
        push(@cmds, [ 6, 1, $m  ]);
    }
    elsif ($logmode =~ /^(velocity),([0-9]+),([0-9]+),([0-9]+),([0-9]+),([0-9]+),
                        ([0-9]+),([0-9]+),([0-9]+),([0-9]+)$/x
           && $2 < $3 && $3 < $4 && $4 < $5 && $5 < $6
           && $7 > 0 && $8 > 0 && $9 > 0 && $10 > 0)
    {
        my $v0 = int($2); my $v1 = int($6);
        my $x1 = int($3); my $x2 = int($4); my $x3 = int($5);
        my $i1 = int($7); my $i2 = int($8); my $i3 = int($9); my $i4 = int($10);
        my $mode = $1; my $m = (LOGMODESNAMES)->{$mode};
        DEBUG1("Setting logmode '%s': m=%i v0=%i x1=%i x2=%i x3=%i v1=%i "
                    . "i1=%i i2=%i i3=%i i4=%i",
                    $mode, $m, $v0, $x1, $x2, $x3, $v1, $i1, $i2, $i3, $i4);
        push(@cmds, [ 6, 2, $v0 ]);
        push(@cmds, [ 6, 3, $v1 ]);
        push(@cmds, [ 6, 5, $x1 ]);
        push(@cmds, [ 6, 6, $x2 ]);
        push(@cmds, [ 6, 7, $x3 ]);
        push(@cmds, [ 6, 9, $i1 ]);
        push(@cmds, [ 6,10, $i2 ]);
        push(@cmds, [ 6,11, $i3 ]);
        push(@cmds, [ 6,12, $i4 ]);
        push(@cmds, [ 6, 1, $m  ]);
    }
    elsif ($logmode =~ /^(time),([0-9]+),([0-9]+),([0-9]+)$/
          && $2 < $3 && $4 > 0)
    {
        my $v0 = int($2); my $v1 = int($3);
        my $t = int($4);
        my $mode = $1; my $m = (LOGMODESNAMES)->{$mode};
        DEBUG1("Setting logmode '%s': m=%i v0=%i v1=%i t=%i",
                    $mode, $m, $v0, $v1, $t);
        push(@cmds, [ 6, 2, $v0 ]);
        push(@cmds, [ 6, 3, $v1 ]);
        push(@cmds, [ 6,13, $t  ]);
        push(@cmds, [ 6, 1, $m  ]);
    }
    elsif ($logmode =~ /^(distance),([0-9]+),([0-9]+),([0-9]+)$/
          && $2 < $3 && $4 > 0)
    {
        my $v0 = int($2); my $v1 = int($3);
        my $d = int($4);
        my $mode = $1; my $m = (LOGMODESNAMES)->{$mode};
        DEBUG1("Setting logmode '%s': m=%i v0=%i v1=%i d=%i",
                    $mode, $m, $v0, $v1, $d);
        push(@cmds, [ 6, 1, $m  ]);
        push(@cmds, [ 6, 2, $v0 ]);
        push(@cmds, [ 6, 3, $v1 ]);
        push(@cmds, [ 6,14, $d  ]);
        push(@cmds, [ 6, 1, $m  ]);
    }
    elsif ($logmode =~ /^(mixed),([0-9]+),([0-9]+),([0-9]+),([0-9]+)$/
          && $2 < $3 && $4 > 0 && $5 > 0)
    {
        my $v0 = int($2); my $v1 = int($3);
        my $t = int($4); my $d = int($5);
        my $mode = $1; my $m = (LOGMODESNAMES)->{$mode};
        DEBUG1("Setting logmode '%s': m=%i v0=%i v1=%i t=%i d=%i",
                    $mode, $m, $v0, $v1, $t, $d);
        push(@cmds, [ 6, 2, $v0 ]);
        push(@cmds, [ 6, 3, $v1 ]);
        push(@cmds, [ 6,13, $t  ]);
        push(@cmds, [ 6,14, $d  ]);
        push(@cmds, [ 6, 1, $m  ]);
    }
    else
    {
        DEBUG1("Illegal logmode specification.");
        return undef;
    }

    # set commands
    foreach my $c (@cmds)
    {
        my @res = $self->gpscmd($c->[0], $c->[1], $c->[2]);
        if ($res[0] != $c->[2])
        {
            ERROR("Failed setting logmode parameter %i: %i.",
                  $c->[1], $res[0]);
            return undef;
        }
    }

    DEBUG1("Log mode set.");
    return 0;
}

# adds or increments suffix if file already exists
sub makefilename
{
    my $self = shift;
    my $filename = shift || die "Need filename.";
    my $extension = shift || '';

      while (-e "$filename$extension")
      {
          # already has a suffix?
          if ($filename =~ m/(.*)\.([0-9]+)$/)
          {
              # increment suffix
              $filename = $1 . "." . ($2+1);
          }
          else
          {
              # add suffix
              $filename .= ".1";
          }
      }
    return "$filename$extension";
}

# save screenshot
sub screenshot
{
    my $self = shift;
    my $outputfile = shift || 'screenshot';

    $outputfile =~ s/\.png$//;
    my $filename = $self->makefilename($outputfile, '.png');

    # ensure that the serial port is opened
    $self->openserial();

    # we don't go into command mode because we don't want a screenshot of
    # the screen displaying "command mode"..

    DEBUG1("Getting screenshot.");

    # tell the device that we want a screenshot
    $self->{io}->write("[CatchScreen]\n");
    $self->{io}->purge_rx();

    DEBUG1("Waiting for screnshot data..\r");

    # FIXME: cleanup
    my $wait = 20;
    my $tt = '';
    my $timeout = 1000;
    my @raw;
    my $firstread = 1;
    my $n = 0;
    my $nn = 0;
    my $nbits = 0;
    my $ncols = 0;
    my $nrows = 0;
    my $expect0 = 0;
    my $expect = 10;
    while (($wait-- > 0 || $nn > 0 || $n < $expect) && $timeout-- > 0)
    {
        # wait a bit and read serial buffer
        usleep(10e3);
        my $t = $self->{io}->input();

        # add data to a buffer
        $tt .= $t;

        # process what is in the buffer so far
        $nn = 0;
        my $idx;
        while ( ($idx = index($tt, "#")) >= $[ && $idx < length($tt)-8)
        {
            # chop the line from the buffer
            $t = substr($tt, $idx, 8);
            $tt = substr($tt, $idx+8);
            $n++;
            $nn++;
            if ($t =~ m/^#(.)(..)(..)(..)/)
            {
                my $b = hex($1);
                my $c = hex($2);
                my $r = hex($3);
                $raw[$b][$c][$r] = hex($4);
                $nbits = $b if ($b > $nbits);
                $ncols = $c if ($c > $ncols);
                $nrows = $r if ($r > $nrows);
                $expect0 = ($nbits * ($ncols+1)*($nrows+1));
                $expect = $expect0 if ($expect0 > $expect);
            }
            $wait = 20;
        }
        local $| = 1;
        printf("\r > n:%04i nbits:%i ncols:%03i nrows:%03i expect:%04i nn:%02i timeout:%04i\r",
               $n, $nbits, $ncols, $nrows, $expect, $nn, $timeout);
    }
    print("\r                                                                             \r");

    if ($timeout <= 0)
    {
        ERROR("Timeout getting screenshot data!");
        return '';
    }

    $ncols++;
    $nrows++;

    my $bitspercol = 8;
    my $ncolours = 2**$nbits;
    my $width = $ncols * $bitspercol;
    my $height = $nrows;
    DEBUG1("Got screenshot: %ix%ipx (%i colours).", $width, $height, $ncolours);

    # make image
    my $img = GD::Image->new($width, $height);
    my @colours;
    for (my $c = 0; $c < $ncolours; $c++)
    {
        my $greylevel = 255 - int($c * 255 / ($ncolours-1));
        $colours[$c] = $img->colorAllocate($greylevel, $greylevel, $greylevel);
    }
    for (my $row = 0; $row < $nrows; $row++)
    {
        for (my $col = 0; $col < $ncols; $col++)
        {
            for (my $offset = 0; $offset < $bitspercol; $offset++)
            {
                my $c;
                for (my $bit = 0; $bit < $nbits; $bit++)
                {
                    $c += (($raw[$bit+1][$col][$row] >> $offset) & 1) << $bit;
                }
                $img->setPixel(($col*$bitspercol)+$bitspercol-$offset, $row, $c);
            }
        }
    }

    # save image

    return $img->png(9);
}


# transforms WGS-84 lat/lon/height to Swiss CH1903 x/y/h (approximation)
# from: Formeln und Konstanten fr die Berechnung der Schweizerischen
# schiefachsigen Zylinderprojektion und der Transformation zwischen
# Koordinatensystemen, Swisstopo, 2004
sub llh2xyz_swiss
{
    my $self = shift;
    my $llh = shift || die "Need reference to list of lat/lon/height";
    my @xyz;

    my $lat = $llh->[0] * 3600; # [arcsec]
    my $lon = $llh->[1] * 3600; # [arcsec]
    my $ele = $llh->[2];

    # intermediate values
    my $p = ($lat - 169028.66) / 10000;
    my $l = ($lon - 26782.5) / 10000;

    # right-hand system, not the silly official system
    $xyz[0] = 600072.37 + 211455.93*$l - 10938.51*$l*$p
      - 0.36*$l*$p*$p - 44.54*$l*$l*$l;
    $xyz[1] = 200147.07 + 308807.95*$p + 3745.25*$l*$l
      + 76.63*$p*$p - 194.56*$l*$l*$p + 119.79*$p*$p*$p;

    # the height from GPS is already orthometric, I think
    #$xyz[2] = $ele - 49.55 + 2.73*$l + 6.94*$p;
    $xyz[2] = $ele;

    return @xyz;
}


# close serial port (no need to call this)
sub closeserial
{
    my $self = shift;

    # return if there's no serial port object
    return if (!defined $self->{io});

    DEBUG2("Closing serial port.");
    $self->{io}->close();
    $self->{io} = undef;
}

# destructor
sub DESTROY
{
    my $self = shift;
    $self->restartgps(); # FIXME: to get out of command mode?
    $self->closeserial();
    DEBUG2("Goodbye!");
}


1;
__END__

=head1 WINTEC PROTOCOL AND LOG FORMAT

=head2 Command Format

send (PC --> GPS): C<@AL,a,b[,p]+CRLF>

read (PC <-- GPS): C<@AL,a,b[,p],OK+CRLF>

Where I<a> and I<n> specify the command and I<p> is an optional parameter to the argument.

In all cases (but command 5,3) the GPS quotes the exact command followed by C<,OK> on success.

On error it outputs C<err_cmd> or C<err_arg> instead of C<OK>.

C<not_support_yet> is returned for commands that are not supported or not implemented.

The GPS will store (or execute) the parameter I<p> when the command is sent to the GPS (setting).

The GPS will return the saved parameter I<p> (payload) if it is not set when sending the command
(polling).

C<+CRLF> is \r\n.

The command C<@AL> (or C<@AL,1xxxx> with password C<xxxx>) is used to "login" to the device. The
device then returns C<LoginOK>.

The WSG-1000 does not react on this command. But the command C<@AL,2,3> will put the device into
command mode, which has the same effect. In fact, it will return C<LoginOK> three times before
acknowledging the command.

=head2 Available Commands

The commands listed below should work on other Wintec receivers as well. However, only the Wintec
WSG-1000 / Navilock NL-120GR has been tested. The commands to and/or responses from this receiver
may look different on other receivers.

=head3 Unknown commands (group 1)

=over

=item CB<1,1,x>, B<1,1>

Apparently sets and gets the "auto sleep counter value". Whatever that would
be. Returns B<not_support_yet> on the NL-120GR.

=item C<1,2,x>, B<1,2>

Apparently sets and gets the "over speed limit value". Returns B<err_cmd> on
the NL-120GR.

=back

=head3 GPS control commands (group 2)

=over

=item C<2,1>

Leaves the command mode and returns C<OK>. Maybe restarts the GPS.

=item C<2,2>

Leaves the command mode and returns C<OK>. Maybe restarts the GPS.

=item C<2,3>

Returns B<OK> and enables command mode (the display reads "Command Mode"). NMEA output is disabled
during command mode (called "bypass" in the original specs).

=item C<2,4>

Returns C<not_support_yet>.

=back

=head3 Unknow commands (group 3)

=over

=item C<3,1,1xxx>

Apparently sets the password to C<xxxx>, where x = [0-9]. Returns C<not_support_yet> on the
NL-120GR.

=item C<3,2>

Apparently disables the password (once logged in with the password). Returns C<not_support_yet> on
the NL-120GR.

=back

=head3 Memory info commands (group 4)

=over

=item C<4,1>

Returns the memory ID (e.g. 48961). This is probably not very useful.

=back

=head3 Logging memory commands (group 5)

The logged data is stored in the memory region returned by the C<5,1> and C<5,2> commands. The
logger starts overwriting memory at the start of the memory when it reaches the end of it (i.e. when
memory is full). Hence, if the address returned by the C<5,2> command is less than the address
returned by C<5,1> command we have to read from the start of log address (returned by the C<5,1>
command) to the end of memory (address returned by the C<5,10> command) and then from the start of
the memory (address returned by the C<5,9> command) to the end of log address (returned by the
C<5,2> command).

=over

=item C<5,1>

Returns the start address of the log in memory (e.g. C<0>)

=item C<5,2>

Returns the end address of the log in memory (e.g. C<23472>)

=item C<5,3,addr>

Returns the chunk of data (up to 4096 bytes) at address C<addr> followed by a
checksum string in the format C<@AL,CS,checksum,addr>. The C<checksum> is the
hex representation of the XOR of all bytes in the data chunk (a 1-2 bytes
string).

=item C<5,4>, C<5,4>

Deletes all log data. Note: takes 4-5 seconds to finish.

=item C<5,5,0>

Returns OK. FIXME: not sure what this does.

=item C<5,6>

Deletes all log and POI data. Note: takes 4-5 seconds to finish.

=item C<5,7,x>

Returns 0, for all C<x> (incl. empty string). FIXME: not sure what this does.

=item C<5,8>

Returns 2097152, which is 2*1024*1024. Probably the total memory size.

=item C<5,9>

Returns log memory start address (e.g. C<0>).

=item C<5,10>

Returns log memory end address (e.g. C<2072576>, which is ~2MB).

=back

=head3 Logging setup commands (group 6)

Probably only positive integer values should be used as arguments to the log
settings commands C<6,2> .. C<6,6>.

=over

=item C<6,1,x>, C<6,1>

Switches logging mode to mode x or returns the currently active logging
mode. C<x> is one of:

C<0> logging off

C<1> "course" logging: toggled by course change above a threshold when within velocity limits.

C<2> "velocity" logging: fixed logging intervals when within corresponding velocity limits.

C<3> "time" logging: fixed logging time interval when within velocity limits.

C<4> "distance" logging: fixed logging distance interval when within velocity limits.

C<5> "mixed" logging: fixed logging distance and time interval when within velocity limits.

Note: this logging mode requires that "User Mode" is enabled in screen B0.

=item C<6,2,v0> / C<6,2>

Sets the lower velocity limit to C<v0> km/h (i.e. minimal velocity) (all
logging modes) or returns the currently set value.

=item C<6,3,v1> / C<6,3>

Sets the upper velocity limit to C<v1> km/h (i.e. max. velocity) (all logging
modes) or returns the currently set value.

=item C<6,4,c> / C<6,4>

Sets the course change threshold to +/- C<c> degrees ("course" logging mode) or
returns the currently set threshold.

=item C<6,5,x1>, C<6,6,x2>, C<6,7,x3> / C<6,5>, C<6,6>, C<6,7>

Sets the velocities in km/h that subdevide the velocity interval defined by the
lower (C<v0>) and the upper velocity limit (C<v1>) ("velocity" logging
mode). It is probably a good idea to ensure that the values meet the following
criteria: C<v0> < C<x1> < C<x2> < C<x3> < C<v1> or returns the currently set
velocities.

=item C<6,9,i1>, C<6,10,i2>, C<6,11,i3>, C<6,12,i4> / C<6,9>, C<6,10>, C<6,11>, C<6,12>

Sets the logging intervals C<i1>, C<i2>, C<i3> and C<i4> in seconds for the
corresponding velocity intervals [C<v0>:C<x1>], [C<x1>:C<x2>], [C<x2>:C<x3>]
and [C<x3>:C<v1>] ("velocity" logging mode) or returns the currently set
intervals.

=item C<6,13,t> / C<6,13>

Sets the logging time interval to C<t> seconds ("time" and "mixed" logging) or
returns the currently set interval.

=item C<6,14,d> / C<6,14>

Sets the logging distance interval to C<d> metres ("distance" and "mixed"
logging) or returns the currently set interval.

=back

=head3 Device info commands (group 7)

Note: you must not use commas (,) in the strings to set the device info because
it is used as a separator in the protocol. And you probably should avoid
non-printable stuff.

=over

=item C<7,1>, C<7,1,name>

Returns the device name (e.g. C<NL-120GR>).

Sets the device name to C<name>. TimeMachineX (TMX) allows 19 characters
here. More seems to be possible but breaks compatibility with TMX. The logger
displays 15 characters of this.

=item C<7,2>, C<7,1,info>

Returns the device info.

Sets the device info to C<info>. TimeMachineX (TMX) allows 19 characters
here. More seems to break compatibility with TMX. A reasonable maximum size
might be 32.

=item C<7,3>, C<7,3,sn>

Returns serial number (e.g. C<SN1234567890>).

Sets the device serial number to C<sn>. TimeMachineX (TMX) does not allow to
set this. A reasonable size limit might be 19 characters like C<info> and C<name>.

=back

=head3 Device version commands (group 8)

=over

=item C<8,1>

Returns the hardware version (e.g. C<CX01-ABC-001>).

=item C<8,2>

Returns the sofware (firmware) date (e.g. C<Nov 24 2008>).

=item C<8,3>

Returns the logging format version (e.g. C<2.0>).

=back

=head3 Unknow commands (group 9)

=over

=item C<9,1,x>

Returns different numbers for different C<x>. FIXME: don't know what this does.

=item C<9,2,x>

Returns C<err_cmd>. FIXME: don't know what this does.

=back

=head3 Marks commands (group 10)

FIXME: not sure about the maximum number of marks on the device. 125 worked
fine on a NL-120GR with firmware 1.1.7.0.

=over

=item C<10,1,i,lat,lon,ele,name>

Stores a mark with icon number C<i> (0-255), latitude/longitude C<lat>/C<lon>
(format: %.5f, 0-90/0-180), elevation C<ele> (format: %i) and the name C<name>
(max. 12 characters). Use negative numbers for southern and western
hemispheres, respectively.

=item C<10,2,n>

Reads mark C<n> (>=0) from device.

=item C<10,3>

Deletes all marks from the device.

=item C<10,4>

Returns number of marks stored on the device.

=back

=head2 Log Data Format

The binary log (as read-out with the B<5,3> command) version 2.0 (see the B<8,3>) consists of 16
bytes long records starting at offset 0 (i.e. no header). Each record holds the date and time,
latitude, longitude, elevation (orthometric height FIXME: really?), some flags and temperature and
pressure readings. The format is as follows:

A record consists of these fields (all little-endian):

=over

=item I<unsigned short int> (16 bits)

The two least significant bits are flags that determine records marked as the start of a new track
and a waypoint, respectively.

The next 5 bits represent the temperature reading. Multiply the value by 2 and substract 10 to get
the temperature in degrees Celsius. The range is -10 .. +52 degrees Celsius. FIXME: sometimes the
value is unexpectedly 0, leading to -10 in the output. We should probably ignore those.

The 7 most significant bits represent the pressure reading. Shift it by 589 to get the ambient
pressure in hPa (mbar). The range is 589 .. 1100 hPa.

=item I<unsigned int> (32 bits)

The 6 least significant bits are the seconds.

The next 6 bits are the minutes.

The next 5 bits are the hours.

The next 5 bits are the days.

The next 4 bits are the months.

And the 6 most significant bits are the years since the year 2000.

=item I<signed int> (32 bits)

Latitude in decimal degrees scaled by 1e7.

=item I<signed int> (32 bits)

Longitude in decimal degrees scaled by 1e7.

=item I<signed short int> (16 bits)

Elevation in metres.

=back

=head2 Screenshots

A screenshot can be requested by sending the string C<[CatchScreen]> (followed by a newline) to the
device. The device will suspend (power off?) the GPS unit, which will stop NMEA output, and return a
number of lines. Then the GPS unit is restarted and NMEA output starts again. The format of these
lines is C<#bccrrpp> (followed by CRLF), where C<b> is the bit of the colour (1 or 2), C<cc> is the
column (2 hex nibbles), C<rr> the row (2 hex nibbles) and C<pp> are the bits (pixels, 2 hex nibbles)
corresponding to 8 pixels of the screen. The screen size of the WSG-1000 is 120x160 px. Hence,
you'll see C<cc> from 0..15 (0x00..0x0e) and C<rr> from 0..159 (0x00..0x9f). The LSB (C<b>) of the
colours of each group of 8 pixels (C<pp>) for all columns and rows is transferred first, followed by
the same list for the MSB. Confusing, isn't it?

=head1 NOTES ON THE WSG-1000 / NL-120GR

=head2 Log Mode

Screen I<B0> allows for setting different log modes. Set it to "User Mode" if you want to use a
customised logging behaviour (C<--logmode>). The "Walk", "Bike" and "Motor" modes are defaults for
the respective activity. Setting one of those does not affect the stored "User Mode" logging
settings.

=head1 TODO

=over

=item * Implement KML export.

=item * Implement unicsv export and maybe a direct interface to gpsbabel.

=item * (Maybe) Implement real tk1 read/write (i.e. bin with header) as used by TMX i in bin_write and bin_read.

=item * Once that's done, use the header information (device name etc.) for --gpx etc.

=item * Implement some good PRINT()s when verbosity = 1.

=item * Handle die()s in WintecGPS nicely (i.e. better don't use them).

=item * Implement port autodetect (/dev/ttyUSB? etc.).

=item * What's the port on Macintosh OS X? And on Windoze?

=item * Implement retries in gpscmd(). Sometimes commands timeout.

=item * What's in the 24k in the memory region "end of log memory address" (5,10) - "total memory size" (5,8)?  Maybe the journey info? Can we read that at all?

=item * Document (names of) icons and make --getmarks and --setmarks use these.

=item * More error handling and propagation.

=item * Add version number.

=item * ...

=back

=head1 CREDITS

=over

=item C. S. for write_gpx().

=item Navilock (http://www.navilock.de).

=item The gpsbabel (http://www.gpsbabel.org), in particular to the authors of the file wbt-200.c.

=item The Perl folks (http://www.ctan.org etc.).

=item The Internets.

=back

=head1 LINKS

=over

=item http://www.wintec.com.tw

=item http://www.navilock.de

=item http://www.wintec-gps.de

=item http://lai0330.googlepages.com/ -- Al's TMX homepage.

=back

=head1 AUTHOR

Philippe Kehl <phkehl at gmail dot com>

http://oinkzwurgl.org/wintectool

https://github.com/phkehl/wintectool


=head1 COPYRIGHT AND DISCLAIMER

This program is Copyright 2009, 2015 by Philippe Kehl.

This program is free software; you can redistribute it and/or modify it under the terms of the Perl
Artistic License or the GNU General Public License as published by the Free Software Foundation;
either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

If you do not have a copy of the GNU General Public License write to the Free Software Foundation,
Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

See the included file C<LICENSE> for the full text.

=cut

# eof
